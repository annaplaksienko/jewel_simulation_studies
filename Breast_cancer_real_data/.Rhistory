NAcols_rowid <- ids[[i]]$NAcols_rowid
A <- dat[-row_id, -all_NA_cols]
B <- dat[-row_id, NAcols_rowid]
C <- dat[row_id, -all_NA_cols]
dim(A)
dim(B)
length(C)
dim(C)
length(B)
str(B)
row_id
NAcols_rowid
max(group_size_by_NAs)
dat <- chr1_before_impt
#let's identify columns with same patterns of NAs
{
colnames_dat <- colnames(dat)
dat_na <- is.na(dat)
dat_na <- dat_na[, colSums(dat_na) > 0]
all_NA_cols <- which(colnames_dat %in% colnames(dat_na))
# Columns with all NAs or a single not NA value to be excluded:
# not enough information for imputation
dat_na <- dat_na[, colSums(dat_na) < (dim(dat_na)[1] - 1)]
#If all the columns have missing values we cannot do anything
if (dim(dat_na)[2] == dim(dat)[2]) {
return("Not enough data to conduct imputation.")
} else {
cat("#cols with #NAs < (#samples - 1):", dim(dat_na)[2], "\n")
}
#if some columns are restricted by user, exclude them
#if(!is.null(col.list)) dat_na <- dat_na[, !col.list]
unique_patterns <- as.matrix(distinct(as.data.frame(t(dat_na))))
ngroups <- dim(unique_patterns)[1]
cat("#regression groups:", ngroups, "\n")
ids <- vector(mode = "list", length = ngroups)
for (i in 1:ngroups) {
curr_pattern <- unique_patterns[i, ]
col_match <- apply(dat_na, 2, function(x) identical(x, curr_pattern))
col_match <- colnames(dat_na)[col_match]
NAcols_rowid <- which(colnames_dat %in% col_match)
row_id <- which(curr_pattern == TRUE)
ids[[i]] <- list(row_id = row_id, NAcols_rowid = NAcols_rowid)
}
names(ids) <- paste("group", c(1:ngroups), sep = "_")
}
dat <- chr1
#let's identify columns with same patterns of NAs
{
colnames_dat <- colnames(dat)
dat_na <- is.na(dat)
dat_na <- dat_na[, colSums(dat_na) > 0]
all_NA_cols <- which(colnames_dat %in% colnames(dat_na))
# Columns with all NAs or a single not NA value to be excluded:
# not enough information for imputation
dat_na <- dat_na[, colSums(dat_na) < (dim(dat_na)[1] - 1)]
#If all the columns have missing values we cannot do anything
if (dim(dat_na)[2] == dim(dat)[2]) {
return("Not enough data to conduct imputation.")
} else {
cat("#cols with #NAs < (#samples - 1):", dim(dat_na)[2], "\n")
}
#if some columns are restricted by user, exclude them
#if(!is.null(col.list)) dat_na <- dat_na[, !col.list]
unique_patterns <- as.matrix(distinct(as.data.frame(t(dat_na))))
ngroups <- dim(unique_patterns)[1]
cat("#regression groups:", ngroups, "\n")
ids <- vector(mode = "list", length = ngroups)
for (i in 1:ngroups) {
curr_pattern <- unique_patterns[i, ]
col_match <- apply(dat_na, 2, function(x) identical(x, curr_pattern))
col_match <- colnames(dat_na)[col_match]
NAcols_rowid <- which(colnames_dat %in% col_match)
row_id <- which(curr_pattern == TRUE)
ids[[i]] <- list(row_id = row_id, NAcols_rowid = NAcols_rowid)
}
names(ids) <- paste("group", c(1:ngroups), sep = "_")
}
gc()
gc()
path <- "home/anna/Skin3D/tab"
setwd(path)
path <- "home/anna/Skin3D/tab/"
setwd(path)
path <- "home/anna/Skin3D/tab"
path <- "home/anna/Skin3D"
setwd(path)
path <- "home/anna/Skin3D"
setwd(path)
getwd()
path <- "home/anna/Skin3D"
setwd(path)
path <- "home/anna/Skin3D_analysis"
setwd(path)
path <- "home/anna/Christine_analysis"
setwd(path)
load("~/Christine_analysis/counts_after_filtering.Rdata")
load("/home/anna/0_jewel/clean/Breast_cancer_real_data/X_real_data.RData")
library(jewel)
path <- "/home/anna/0_jewel/clean/Breast_cancer_real_data"
setwd(path)
lambda <- generateLambdaGrid(X, n = 50, eps = 0.01)
remove.packages("jewel", lib="~/R/x86_64-pc-linux-gnu-library/4.1")
install.packages("~/0_jewel/clean/jewel_2.0.0.tar.gz", repos = NULL, type = "source")
lambda_BIC_no_warm_up <- estimateLambdaBIC(X, lambda,
tol = 0.001, warmup = FALSE)
?estimateLambdaBIC
library(jewel)
lambda_BIC_no_warm_up <- estimateLambdaBIC(X, lambda,
tol = 0.001, warmup = FALSE)
remove.packages("jewel", lib="~/R/x86_64-pc-linux-gnu-library/4.1")
install.packages("~/0_jewel/clean/jewel_2.0.0.tar.gz", repos = NULL, type = "source")
library(jewel)
lambda_BIC_no_warm_up <- estimateLambdaBIC(X, lambda,
tol = 0.001, warmup = FALSE)
?estimateLambdaBIC
?estimateLambdaBIC
#' Joint node-wise estimation of Gaussian graphical model from multiple datasets
#'
#' Identify direct connection (conditional dependencies) between variables given several datasets with the same variable measured under slightly different conditions.
#'
#' @param X List of \code{K} numeric data matrices of \code{n_k} samples and \code{p} variables (\code{n_k} can be different for each matrix).
#' @param lambda1 Regularization parameter 1
#' @param lambda2 Regularization parameter 2. If NULL, set to \code{\lambda_2 = \lambda_1 * 1.4}
#' @param Theta List of \code{K} starting regression coefficient matrices of size \code{p} by \code{p}. If NULL, initialized as all zeros.
#' @param W List of \code{K} weights matrices of size \code{p} by \code{p}. If NULL, initialized as all ones.
#' @param tol Convergence threshold controlling the relative error between iterations. The default value is 0.01.
#' @param maxIter Maximum allowed number of iterations. The default value is 10 000.
#' @param verbose If verbose = FALSE, tracing information printing is disabled. The default value is TRUE.
#'
#' @importFrom SMUT eigenMapMatMult
#'
#' @return The following list is returned
#' \itemize{
#'   \item \code{CommonG} - adjacency matrix of the common estimated graph
#'   \item \code{G_list} - adjacency matrices of the each estimated graph
#'   \item \code{Theta} - list of \code{K} estimated covariance matrices of size \code{p} by \code{p}
#' }
#'
#' @export
jewel2_BIC2 <- function (X, lambda1, lambda2 = NULL,
Theta = NULL, W = NULL,
tol = 0.01, maxIter = 10000,
verbose = TRUE) {
#get number of input matrices
K <- length(X)
#get dimensions of each matrix
n_k <- sapply(X, function(x) dim(x)[1])
p <- dim(X[[1]])[2]
#normalize the data
X <- mapply(function(y) scale(y), X, SIMPLIFY = FALSE);
#assemble a long X matrix (faster than lists)
Xl <- do.call(rbind, X)
nindex <- rep(1:K, n_k)
index <- c(1:K)
#Theta - list of regression coefficient matrices
#Active - matrix indicating current active variables in the common part
#Active_K_long - matrices indicating current active variables in each whole graph
#R_specific and R_common - residuals
#zero diagonals are dropped
if (is.null(Theta)) {
Theta <- Xi <- Gamma <- matrix(0, nrow = (p - 1) * K, ncol = p);
Active <- matrix(TRUE, nrow = (p - 1), ncol = p);
Active_K_long <- matrix(TRUE, nrow = (p - 1) * K, ncol = p);
R_specific <- R_common <- Xl;
#auxilary, find better solution later
Gamma_list <- rep(list(NA), K)
Xi_list <- rep(list(NA), K)
} else {
r <- mapply(function(x, y) x - eigenMapMatMult(x, y),
X, Theta, SIMPLIFY = FALSE)
R_specific <- R_common <- do.call(rbind, r)
remove(r)
Active <- lapply(Theta, function(x) x != 0)
Active <- Reduce('+', Active)
Active <- (Active == 3)
Xi <- lapply(Theta, function(x) x[Active])
Gamma <- mapply(function(x, y) x - y,
Theta, Xi)
Active_K <- lapply(Gamma, function(x) removeDiagonal(x != 0))
Active_K_long <- do.call(rbind, Active_K)
remove(Active_K)
Gamma <- lapply(Gamma, removeDiagonal)
Gamma <- do.call(rbind, Gamma)
Xi <- lapply(Xi, removeDiagonal)
Xi <- do.call(rbind, Xi)
#auxilary, find better solution later
Gamma_list <- rep(list(NA), K)
Xi_list <- rep(list(NA), K)
}
#if weights are not provided, set them to 1
if (is.null(W) == 1) {
W <- matrix(1, nrow = (p - 1) * K, ncol = p);
} else {
W <- lapply(W, removeDiagonal)
W <- do.call(rbind, W)
}
#if second regularization not provided, set it to lambda_2 = 1.4 * lambda_1
if (is.null(lambda2) == 1) {
lambda2 <- lambda1 * 1.4
}
#to avoid dividing by zero
eps <- 2.220446e-16
numIter <- 1;
check_conv <- 10000;
if (verbose) message("1/3 Initialization completed. Starting iterations. Iteration number...")
while (numIter <= maxIter && check_conv > tol) {
numIter <- numIter + 1
if (verbose) message(numIter - 1)
Theta_old <- Theta;
order1 <- sample(1:(p-1), size = (p-1))
#COMMON part (fix Gamma, update XI)
for (j in order1) {
#choose under-diagonal elements for j-th column
#get indices of those which are TRUE
Act <- (j-1) + which(Active[j:(p - 1), j], arr.ind = TRUE)
if (length(Act) == 0) break
jminus <- setdiff(1:p, j)
for (a in 1:length(Act)) {
aminus <- setdiff(1:p, Act[a] + 1)
za <- c(NA, K)
zb <- c(NA, K)
za <- sapply(index, function (k)
(1 / n_k[k]) * Xl[nindex == k, jminus[Act[a]]] %*% R_common[nindex == k, j] +
Xi[(p - 1) * (k - 1) + Act[a], j])
zb <- sapply(index, function (k)
(1 / n_k[k]) * Xl[nindex == k, aminus[j]] %*% R_common[nindex == k, Act[a] + 1] +
Xi[(p - 1) * (k - 1)  + j, Act[a] + 1])
z <- c(za, zb);
W_avr <- mean(sapply(index, function(k) W[(p - 1) * (k - 1)  + j, Act[a] + 1]))
thrld <- 1 - lambda1 * sqrt(2 * K) * W_avr / (sqrt(sum(z^2)) + eps)
if (thrld <= 0) {
z <- z * 0;
Active[j, Act[a] + 1] <-  FALSE;
Active[Act[a], j] <- FALSE;
} else {
z <- z * thrld;
}
za <- z[1:K];
zb <- z[(K + 1) : (2 * K)];
R_common[ , j] <- unlist(lapply(index, function (k)
R_common[nindex == k, j] - Xl[nindex == k, jminus[Act[a]]] *
(za[k] - Xi[(p - 1) * (k - 1) + Act[a], j])))
R_common[, Act[a] + 1] <- unlist(lapply(index, function (k)
R_common[nindex == k, Act[a] + 1] - Xl[nindex == k, aminus[j]] *
(zb[k] - Xi[(p - 1) * (k - 1) + j, Act[a] + 1])))
for (k in index) {
Xi[(p - 1) * (k - 1) + Act[a], j] <- za[k]
Xi[(p - 1) * (k - 1) + j, Act[a] + 1] <- zb[k]
}
}
}
#update R_specific
{
for (i in 1:K) {
Gamma_list[[i]] <- addZeroDiagonal(Gamma[((p - 1) * (i - 1) + 1) : ((p - 1) * i),]);
Xi_list[[i]] <- addZeroDiagonal(Xi[((p - 1) * (i - 1) + 1) : ((p - 1) * i),]);
}
update <- mapply(function(x, y, z) x - eigenMapMatMult(x, y) - eigenMapMatMult(x, z),
X, Gamma_list, Xi_list, SIMPLIFY = FALSE)
R_specific <-  do.call(rbind, update)
}
order2 <- sample(1:(p-1), size = (p-1))
#SPECIFIC part (fix Xi, update GAMMA)
for (k in 1:K) {
for (j in order2) {
#choose under-diagonal elements for j-th column
#get indices of those which are TRUE
Act <- (p - 1) * (k - 1) + (j - 1) +
which(Active_K_long[((p - 1) * (k - 1) + j): ((p - 1) * k), j],
arr.ind = TRUE);
if (length(Act) == 0) break;
#for all active variables in the current column
for (a in 1:length(Act)) {
i <- Act[a] + k - p * (k - 1)
za <- (1 / n_k[k]) * Xl[nindex == k, i] %*% R_specific[nindex == k, j] +
Gamma[Act[a], j]
zb <- (1 / n_k[k]) * Xl[nindex == k, j] %*% R_specific[nindex == k, i] +
Gamma[(p - 1) * (k - 1)  + j, i]
z <- c(za, zb);
thrld <- 1 - lambda2 * sqrt(2) * W[(p - 1) * (k - 1)  + j, i] / (sqrt(sum(z^2)) + eps)
if (thrld <= 0) {
z <- z * 0;
Active_K_long[Act[a], j] <- FALSE
Active_K_long[(p - 1) * (k - 1) + j, i] <- FALSE
} else {
z <- z * thrld;
}
za <- z[1]
zb <- z[2]
R_specific[nindex == k, j] <- R_specific[nindex == k, j] - Xl[nindex == k, i] *
(za - Gamma[Act[a], j])
R_specific[nindex == k, i] <- R_specific[nindex == k, i] - Xl[nindex == k, j] *
(zb - Gamma[(p - 1) * (k - 1) + j, i])
Gamma[Act[a], j] <- za
Gamma[(p - 1) * (k - 1) + j, i] <- zb
}
}
}
#update R_common
{
for (i in 1:K) {
Gamma_list[[i]] <- addZeroDiagonal(Gamma[((p - 1) * (i - 1) + 1) : ((p - 1) * i),]);
Xi_list[[i]] <- addZeroDiagonal(Xi[((p - 1) * (i - 1) + 1) : ((p - 1) * i),]);
}
update <- mapply(function(x, y, z) x - eigenMapMatMult(x, y) - eigenMapMatMult(x, z),
X, Gamma_list, Xi_list, SIMPLIFY = FALSE)
R_common <-  do.call(rbind, update)
}
#check convergence
Theta <- Xi + Gamma
check_conv <- sum(abs(Theta - Theta_old)) / (sum(abs(Theta_old)) + eps)
}
message((paste0("jewel: Total number of iterations is ", numIter - 1, " and error is ", check_conv)))
if (verbose) message("2/3 Iterations completed. Assembling the output...")
#evaluate BIC
BIC <- sum(sapply(index, function(c) n_k[c] * sum(apply(R_common[nindex == c, ], 2,
function (y) log( sum(y^2) ) ) ) ) ) +
sum(sapply(n_k, log) * sapply(index, function(c) sum(Active_K_long[nindex == c, ]) / 2))
Theta_list <- rep(list(NA), K)
A_list <- rep(list(NA), K)
for (i in 1:K) {
Theta_list[[i]] <- addZeroDiagonal(Theta[((p - 1) * (i - 1) + 1) : ((p - 1) * i), ])
A_list[[i]] <- (Theta_list[[i]] != 0)
colnames(A_list[[i]]) <- rownames(A_list[[i]]) <- colnames(X[[i]])
}
#common graph is the intersection of K estimated graphs
A <- Reduce('+', A_list)
A <- (A == K)
if (verbose) message("3/3 Completed.")
return(list(CommonG = A,
G_list = A_list,
Theta = Theta_list,
Gamma = Gamma_list,
Xi = Xi_list,
BIC = BIC));
}
library(jewel)
path <- "/home/anna/0_jewel/clean/Breast_cancer_real_data"
setwd(path)
load("X_real_data.RData")
lambda <- generateLambdaGrid(X, n = 30, eps = 0.01)
#' Estimation of the optimal regularization parameter for jewel method with Bayesian information criterion
#'
#' Given a grid of regularization parameters, function evaluates Baeysian information criterion (BIC) for each element.
#' Optimal lambda is chosen as the one for which BIC's minimum is obtained. Warm start is implemented.
#'
#' @param X list of \code{K} numeric data matrices of size \code{n_k} by \code{p} (\code{n_k} can be different for each matrix)
#' @param lambda vector of parameters for which function evaluates BIC
#' @param tol Convergence threshold controlling the relative error between iterations. The smaller it is, more precise are BIC. The default value is 0.0001.
#' @param warmup Whether to use matrices computed with previous \code{lambda} as a starting point for the current \code{lambda}. The default is TRUE.
#' @param makePlot If makePlot = FALSE, plotting of BIC is disabled. The default value is TRUE.
#'
#' @return The following list is returned
#' \itemize{
#'   \item \code{lambda_opt} - a number, optimal value of regularization parameter according to BIC procedure;
#'   \item \code{BIC} - a vector of BICs for each element of input vector \code{lambda}.
#' }
#'
#' @export
estimateLambdaBIC2 <- function (X, lambda, tol = 0.0001,
warmup = TRUE, makePlot = TRUE) {
message("1/4 Starting iterations over lambda. Iteration number...")
BIC <- rep(NA, length(lambda))
if (warmup == TRUE) {
for (l in 1:length(lambda)) {
timestamp()
message(paste0("Computing for lambda", l))
if (l != 1) {
jewel_result <- jewel2(X, lambda[l],
Gamma = Gamma_warm_up,
Xi = Xi_warm_up,
tol,
verbose = FALSE);
} else {
jewel_result <- jewel2(X, lambda[l],
tol,
verbose = FALSE);
}
BIC[l] <- jewel_result$BIC
Gamma_warm_up <- jewel_result$Gamma
Xi_warm_up <- jewel_result$Xi
}
} else {
for (l in 1:length(lambda)) {
timestamp()
message(paste0("Computing for lambda", l))
jewel_result <- jewel2_BIC2(X, lambda[l],
tol,
verbose = FALSE);
BIC[l] <- jewel_result_BIC2$BIC
}
}
message("2/4 Completed. Estimating the optimal lambda...")
#if minimum is achieved for two lambdas, we will get first one
lambda_opt_BIC <- lambda[which.min(BIC)]
message(paste0("3/4 BIC optimal lambda is ", lambda_opt_BIC, ". Generating the plot..."))
if (makePlot == TRUE) {
plot(lambda, BIC, type = "p", col = "blue");
points(lambda_opt_BIC, BIC[which.min(BIC)], col = "red");
}
message("4/4 Completed.")
return(list(lambda_opt = lambda_opt_BIC,
BIC_values = BIC))
}
lambda_BIC_another_warm_up <- estimateLambdaBIC2(X, lambda,
tol = 0.001, warmup = TRUE)
##------ Mon Aug 22 01:12:54 2022 ------##
##------ Mon Aug 22 01:37:26 2022 ------##
##------ Mon Aug 22 01:38:50 2022 ------##
##------ Mon Aug 22 01:40:47 2022 ------##
##------ Mon Aug 22 01:43:37 2022 ------##
##------ Mon Aug 22 01:44:18 2022 ------##
##------ Mon Aug 22 01:44:28 2022 ------##
##------ Mon Aug 22 01:44:54 2022 ------##
##------ Mon Aug 22 01:45:35 2022 ------##
##------ Mon Aug 22 01:46:14 2022 ------##
##------ Mon Aug 22 01:46:43 2022 ------##
##------ Mon Aug 22 01:47:16 2022 ------##
##------ Mon Aug 22 01:47:42 2022 ------##
##------ Mon Aug 22 01:48:13 2022 ------##
##------ Mon Aug 22 01:48:35 2022 ------##
##------ Mon Aug 22 01:48:46 2022 ------##
##------ Mon Aug 22 01:48:55 2022 ------##
##------ Mon Aug 22 01:49:07 2022 ------##
##------ Mon Aug 22 01:49:18 2022 ------##
##------ Mon Aug 22 01:49:34 2022 ------##
##------ Mon Aug 22 01:49:45 2022 ------##
##------ Mon Aug 22 01:49:56 2022 ------##
##------ Mon Aug 22 01:50:11 2022 ------##
##------ Mon Aug 22 01:50:33 2022 ------##
##------ Mon Aug 22 01:50:45 2022 ------##
##------ Mon Aug 22 01:50:56 2022 ------##
##------ Mon Aug 22 01:51:33 2022 ------##
##------ Mon Aug 22 01:51:41 2022 ------##
##------ Mon Aug 22 01:51:49 2022 ------##
##------ Mon Aug 22 01:52:26 2022 ------##
plot(lambda, lambda_BIC_another_warmup$BIC_values, type = "l")
plot(lambda, lambda_BIC_another_warm_up$BIC_values, type = "l")
eps1 <- 0.01
eps2 <- 0.3
nlambda <- 20
lambda <- exp(seq(log(eps1), log(eps2), length.out = nlambda))
lambda_BIC_another_warm_up <- estimateLambdaBIC2(X, lambda,
tol = 0.001, warmup = TRUE)
##------ Mon Aug 22 15:30:52 2022 ------##
eps1 <- 0.01
eps2 <- 0.3
nlambda <- 10
eps1 <- 0.01
eps2 <- 0.3
nlambda <- 10
lambda <- exp(seq(log(eps1), log(eps2), length.out = nlambda))
lambda_BIC_another_warm_up <- estimateLambdaBIC2(X, lambda,
tol = 0.0001, warmup = TRUE)
##------ Mon Aug 22 15:31:18 2022 ------##
##------ Mon Aug 22 15:47:03 2022 ------##
##------ Mon Aug 22 15:47:54 2022 ------##
##------ Mon Aug 22 15:53:49 2022 ------##
##------ Mon Aug 22 15:55:28 2022 ------##
##------ Mon Aug 22 16:06:07 2022 ------##
##------ Mon Aug 22 16:08:32 2022 ------##
##------ Mon Aug 22 16:14:58 2022 ------##
##------ Mon Aug 22 16:20:32 2022 ------##
##------ Mon Aug 22 16:22:07 2022 ------##
lambda1 <- generateLambdaGrid(X, nlambda = 50, eps = 0.01)
lambda1
lambda1 <- generateLambdaGrid(X, nlambda = 30, eps = 0.01)
lambda1
library(jewel)
?jewel
library(igraph)
path <- "/Users/annapla/Documents/1_CNR/5_jewel/jewel_studies/jewel_simulation_studies/Breast_cancer_real_data"
setwd(path)
load("X_real_data.RData")
load("string_network_3%_hub10.Rdata")
res <- jewel(X, lambda = 0.35, W = W_list, stability = TRUE)
res <- jewel(X, lambda1 = 0.35, W = W_list, stability = TRUE)
View(res)
G_list <- res$G_list
G <- res$CommonG
library(igraph)
G_list_graph <- lapply(G_list, function(x)
graph_from_adjacency_matrix(x, mode = "undirected"))
sapply(G_list, gsize)
sapply(G_list_graph, gsize)
G <- graph_from_adjacency_matrix(G, mode = "undirected")
G <- res$CommonG
G_graph <- graph_from_adjacency_matrix(G, mode = "undirected")
gsize(G_graph)
sapply(G_list_graph, function(x) gsize(graph.intersection(x, G_string)))
gsize(graph.intersection(G_graph, G_string))
#hypergeometic distibution
num_vert <- 900
all_poss_edges <- num_vert * (num_vert - 1) / 2
in_string <- gsize(G_string)
not_in_string <- all_poss_edges - in_string
pred_edges <- sapply(G_list_graph, gsize)
pred_edges
inters_edges <- sapply(G_list_graph, function(x)
gsize(graph.intersection(x, G_string)))
inters_edges <- sapply(G_list_graph, function(x)
gsize(graph.intersection(x, G_string)))
inters_edges
hypergeomtest <- phyper(q = inters_edges, m = in_string, n = not_in_string,
k = pred_edges, lower.tail = FALSE)
hypergeomtest
hypergeomtest < 10^(-20)
#find the vertices with the highest degree
hubs_est <- lapply(G_list_graph, function(x) sort(degree(x), decreasing = TRUE)[1:30])
hubs_est
names(hubs_est[[1]])
hubs_est[[1]][hubs_est[[1]] %in% top30]
